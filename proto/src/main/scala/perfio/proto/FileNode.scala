package perfio.proto

import com.google.protobuf.DescriptorProtos.FileDescriptorProto
import perfio.TextOutput

import java.io.PrintStream


class FileNode(val desc: FileDescriptorProto, val root: RootNode) extends ParentNode {
  def file: FileNode = this
  val name: String = desc.getName
  val protoPackage: String = desc.getPackage
  val fqName: String = s".$protoPackage"
  val javaMultipleFiles: Boolean = desc.getOptions.getJavaMultipleFiles
  val outerClassName: String = {
    if(desc.getOptions.hasJavaOuterClassname) desc.getOptions.getJavaOuterClassname
    else {
      var n = name.split('/').last
      Util.mkUpperJavaName(if(n.endsWith(".proto")) n.dropRight(6) else n)
    }
  }
  val javaPackageName: String = {
    root.packageOverride.getOrElse {
      if(desc.getOptions.hasJavaPackage) desc.getOptions.getJavaPackage
      else protoPackage
    }
  }
  val javaOutputFileName = {
    val s = s"${outerClassName}.java"
    if(javaPackageName.isEmpty) s else javaPackageName.replace('.', '/') + "/" + s
  }
  val fqJavaOuterClassName: String = if(javaPackageName.isEmpty) outerClassName else s"${javaPackageName}.$outerClassName"
  val fqJavaName: String = if(javaMultipleFiles) javaPackageName else fqJavaOuterClassName
  val syntax: Syntax = desc.getSyntax match {
    case "proto2" => Syntax.Proto2
    case "proto3" => Syntax.Proto3
    case _ => Syntax.Unknown
  }

  desc.getEnumTypeList.forEach(e => enums += new EnumNode(e, this))
  desc.getMessageTypeList.forEach(m => messages += new MessageNode(m, this))

  override def toString: String = s"file $protoPackage/$name (Java: $fqJavaOuterClassName) $syntax"

  override def dump(out: PrintStream, prefix: String): Unit = {
    out.println(s"${prefix}$this")
    super.dump(out, prefix)
  }

  def emit(to: TextOutput, prefix: String): Unit = {
    to.println("// Generated by perfio-proto. Do not edit!")
    to.println(s"// source: ${name}")
    to.println()
    if(javaPackageName.nonEmpty) {
      to.println(s"${prefix}package $javaPackageName;")
      to.println()
    }
    to.println(s"${prefix}public final class $outerClassName {")
    to.println(s"${prefix}  private $outerClassName() {}")
    enums.foreach { e =>
      to.println
      e.emit(to, prefix + "  ")
    }
    messages.foreach { m =>
      to.println
      m.emit(to, prefix + "  ")
    }
    to.println(s"${prefix}}")
  }
}


sealed abstract class Syntax
object Syntax {
  case object Proto2 extends Syntax
  case object Proto3 extends Syntax
  case object Unknown extends Syntax
}
